#!/bin/bash
# SPDX-License-Identifier: GPL-2.0
# Copyright (C) 2018-present Team LibreELEC (https://libreelec.tv)

# Handler for git
# Usage (in package.mk):
# PKG_URL (mandatory) must point to a git repository (git://... or https://example.com/repo.git)
# PKG_VERSION (mandatory) must point to a commit SHA, e.g. a1b2c3d
# PKG_GIT_SHA (optional) full hash of git commit
# PKG_GIT_CLONE_BRANCH (optional) clone specific branch
# PKG_GIT_CLONE_SINGLE (optional) clone single branch only (set to yes)
# PKG_GIT_CLONE_DEPTH (optional) history to clone, must be a number
# PKG_GIT_SUBMODULE_DEPTH (optional) history of submodules to clone, must be a number

set -e
set -o pipefail

_clean_repo() {
  git clean -fdx
  git checkout -- .
}

_repo_exists_and_valid() {
  if [[ -d "${PACKAGE}" ]]; then
    pushd "${PACKAGE}" > /dev/null
    _clean_repo || return 1

    if ! git ls-remote . | grep -q -m1 "^${PKG_VERSION}"; then
      echo "ERROR: ${PACKAGE}: failed to determine git HEAD" >&2
      return 1
    fi

    if [[ "${PKG_URL}" != "$(git remote get-url origin)" ]]; then
      echo "ERROR: ${PACKAGE}: failed to obtain URL of origin" >&2
      return 1
    fi

    if [[ -n "${PKG_GIT_CLONE_BRANCH}" && "${PKG_GIT_CLONE_BRANCH}" != "$(git rev-parse --abbrev-ref HEAD)" ]]; then
      echo "ERROR: ${PACKAGE}: failed to determine current git branch" >&2
      return 1
    fi

    popd > /dev/null
    return 0
  fi
  return 1
}

_get_repo() {
  local git_params="--recursive --shallow-submodules --filter=tree:0"
  [[ -n "${PKG_GIT_CLONE_BRANCH}" ]] && git_params+=" --branch ${PKG_GIT_CLONE_BRANCH}"
  [[ "${PKG_GIT_CLONE_SINGLE}" == "yes" ]] && git_params+=" --single-branch"

  if [[ -n "${PKG_GIT_CLONE_DEPTH}" ]]; then
    if [[ "${PKG_GIT_CLONE_DEPTH}" =~ ^[0-9]+$ ]]; then
      git_params+=" --depth ${PKG_GIT_CLONE_DEPTH}"
    else
      echo "ERROR: PKG_GIT_CLONE_DEPTH is not a number! (${PKG_GIT_CLONE_DEPTH})" >&2
      return 1
    fi
  fi

  git clone "${git_params}" "${PKG_URL}" "${PACKAGE}" || return 1
}

_update_submodules() {
  git submodule update --init --recursive "${GIT_SUBMODULE_PARAMS}" || return 1
}

# Check if repo already exists and is valid
_repo_exists_and_valid && exit 0

# Acquire lock on source dir and re-check
lock_source_dir "${1}"
_repo_exists_and_valid && exit 0

# If not valid, proceed to get the repo
build_msg "CLR_GET" "GET" "${1} (git)" "indent"

# Remove stale stamps
rm -f "${STAMP_URL}" "${STAMP_SHA}"

# Clone or update the repository
if ! _repo_exists_and_valid; then
  _get_repo || exit 1
elif [[ -n "${GIT_DIR}" ]] && [[ "${GIT_DIR}" != "${PACKAGE}" ]]; then
  mv "${GIT_DIR}" "${PACKAGE}" || exit 1
fi

pushd "${PACKAGE}" > /dev/null
git reset --hard "${PKG_VERSION}" || exit 1
_update_submodules || exit 1
popd > /dev/null

# Verify the git hash
GIT_SHA="$(git ls-remote "${PACKAGE}" | grep -m1 HEAD | awk '{print $1;}')" || exit 1
if [[ -n "${PKG_GIT_SHA}" && "${PKG_GIT_SHA}" != "${GIT_SHA}" ]]; then
  build_msg "CLR_WARNING" "WARNING" "Incorrect git hash in repository: got ${GIT_SHA}, wanted ${PKG_GIT_SHA}" >&2
  exit 1
fi
